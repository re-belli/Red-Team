# üõ°Ô∏è Windows EDR Evasion & Malware Development

Notes on malware development and EDR. Most notes will be based on CrowdStrike but I will highlight other EDRs as well.  
Hot takes ahead. This document is based on personal experience and experimentation ‚Äî take it with a grain of salt.

---

## üìå Table of Contents

1. [EDR Components](#-edr-components)  
2. [Malware OPSEC](#-malware-opsec)  
3. [Loader Techniques](#-loader-techniques)  
4. [Code Injection Techniques](#-code-injection-techniques)  
5. [Shellcode Execution Functions](#-shellcode-execution-functions)

---

## üß© EDR Components

- **User-mode API hooking**: After Microsoft introduced PatchGuard in 2005, security vendors moved their hooks from the kernel to user-mode APIs like those in `ntdll.dll`.  
  - [HookFinder](https://github.com/fin3ss3g0d/HookFinder) ‚Äì tool to detect hooked functions in `ntdll.dll`  
  - [Falcon Hooks in ntdll](https://github.com/kyxiaxiang/AV_EDR_EPP_Notes) ‚Äì shows the functions Falcon hooks in ntdll.  
  - This blog gives a good overview on the cat/mouse game for utilizing syscalls against EDR, https://d01a.github.io/syscalls/. 
  - Direct Syscalls IOC - Return address will point to .text and not ntdll. 
  - Indirect Syscall IOC - Using ETWTI stack tracing, EDRs can check where the system call orginated before jumping to ntdll. Which will show it came from .text. 

  <p>
Most popular EDRs are still not using ETW-TI (Event Tracing for Windows ‚Äì Threat Intelligence) for stack tracing. As the author of Brute Ratel pointed out in <a href="https://x.com/NinjaParanoid/status/1735682419569930362" target="_blank">this post</a>, Falcon currently relies on Vectored Exception Handlers (VEH) for stack inspection rather than ETWTI. This remains true today, although it could change in the future. I‚Äôve seen direct syscall loaders bypass Falcon, which suggests they may not be leveraging <code>KPROCESS!InstrumentationCallback</code> to validate return addresses.
</p>
 

- **Kernel callbacks**:  
  - PsSetCreateThreadNotifyRoutine ‚Äì monitors thread creation and termination events  
  - PsSetCreateProcessNotifyRoutine ‚Äì monitors process creation and termination  
  - PsSetLoadImageNotifyRoutine ‚Äì tracks DLL and EXE image loads into process memory  
  - CmRegisterCallbackEx ‚Äì monitors registry operations like key creation, deletion, and value modification  
  - ObRegisterCallbacks ‚Äì monitors access to kernel objects like processes and threads, allowing filtering or blocking of handle operations

- **ETW-TI telementry**:
  - to track specific actions like allocations on executable pages and changing executable pages to writable
  - Can be used to trace call stacks but not widely used. 

- **Sandbox and Behavioral Analysis**:  
  - Runs suspicious files in a cloud sandbox to observe runtime behavior
  - Monitors process, registry, file, network, and memory activity
  - Scores behavior using heuristics, YARA rules, string, and entropy analysis to detect shellcode, suspicious API calls, and known malware traits.
  - Captures stack traces, API usage, and execution flow for forensic review

- **Cloud Telemetry and Cross-Endpoint Correlation**:  
  - Enables host-based behavioral correlation by linking related events (e.g., Outlook ‚Üí Edge ‚Üí Explorer ‚Üí cmd.exe ‚Üí conhost.exe ‚Üí binary.exe ‚Üí network comms)  
  - Uses IOCs, event sequences, and machine learning to flag anomalies across multiple systems  
  - Performs shadow upload of binary data from endpoints to support sandbox detonation and scoring, even when file submission is disabled

---

## üïµÔ∏è Malware OPSEC

- Utilizing powershell is risky due to script-block logging, especially with integration to Splunk which I see a lot. Script-Block logging is a feature of managed PowerShell host, so Cobalt Strike/Havoc's PowerPick can side-step this due to it being unmanaged. But it still requires loading System.Management.Automation.dll which blue teams can hook/monitor. 

- Languages - CIA recommended malware should be under 150KB
  - Golang - Well above the limit; statically compiled with a large IAT. Uses its own runtime and stack layout, which differs from standard C/C++ calling conventions, making tracing harder.  
  - Rust - Also above the limit; its stack layout and compilation model differ from standard C/C++ conventions, which can complicate tracing. Unlike Go, Rust supports dynamic linking, allowing smaller binaries and more flexible deployment. 
  - C - Optimal for size, but easiest to trace since conventions and patterns are well understood by security tools.  
  - C++ - Also compact; classes add complexity. Vtable tracing is less automated in many analysis tools. 
  - C# - Can be under the size limit; every Windows client includes .NET (e.g., .NET Framework 4.7), and assemblies can run in memory by default with the CLR loaded. I have seen great success against Falcon with .Net assemblies, especially when AMSI and ETW are mitigated. You can also make a .Net assembly that runs unmanaged code such as indirect syscalls. 

  - If possible use aged domains, raw ips stick out. Use a seperate domain for exfilitration. 
  - Avoid shell commands, use bof files for modules that perform basic C2 functions. 

---

## üß™ Loader Techniques

  ### üîí Good OPSEC Practices

  #### Obfuscate Strings  
  - Malicious strings that show DLL loading, API resolving, and network comms are bad OPSEC.  

  #### Stage Encrypted Shellcode  
  - Falcon is highly sensitive to entropy and leverages Shannon entropy to measure the randomness of data. By staging encrypted shellcode and downloading it during execution, you can significantly reduce the entropy of the binary itself. In addition, using string lookup tables for encrypted strings ‚Äî with generic words as keys ‚Äî further lowers entropy. This approach also allows you to blend in strings taken from other signed or approved binaries.

  #### Remove IAT Imports  
  - From an OPSEC perspective, it is often considered best practice to avoid having an Import Address Table (IAT). This also means removing the C Runtime (CRT), since it will automatically import many `Kernel32` libraries even if they are not explicitly used. In practice, this can be good OPSEC, but it is not strictly required ‚Äî as long as nothing directly related to malicious functionality appears in the IAT.

  #### Anti-Sandbox  
  - Falcon has the best sandbox, and evading it is crucial to avoid flagging. Most public techniques are deprecated or ineffective, and Falcon detects long sleeps, even patching the sleep function in the IAT. Doing regular busy work and breaking up standard patterns of malicious actions works well, and implementing custom sorting algorithms can provide natural time gaps while making behavior harder to trace. Network communications are not executed inside the sandbox, which is why avoiding import libraries for comms in the IAT prevents patching. If you stick to regular computation and only act once a network callout succeeds, you have a better chance of avoiding detection.

  #### Unhooking  
  - Falcon does a lot of its analysis via user‚Äëmode hooks. If you try to load C2s that aren‚Äôt implemented via direct/indirect syscalls, they will still flag even if the loader doesn‚Äôt. [Birdnet PoC](https://github.com/inb1ts/birdnet-poc)  

  #### Disable AMSI/ETW  
  - Using hardware breakpoints is often considered good OPSEC online, but Falcon hooks `NtGetContextThread`, `NtSetContextThread`, `ZwGetContextThread`, and `ZwSetContextThread`. As a result, all the implementations I‚Äôve seen publicly available will be flagged.  
  A custom patch for `AmsiScan` in CLR works fine. For ETW, using an EAT hook or utilizing an egghunter to patch ETW also works.

  #### Custom Functions & Dynamic Linking  
  - Falcon is extremely sensitive to having IAT entries fore `GetProcAddress` and `GetModuleHandle` to resolve libraries, functions, and syscalls. Use custom implementations of these functions, and consider TartarusGate to resolve syscalls. On most Windows builds, the `SSN` can be found at the 4th byte of the function stub, while the actual `syscall` instruction is typically located at an offset of 0x12. By using an obfuscated or encrypted `GetProcAddress`, you can extract both the syscall ID and the syscall address to execute indirect syscall.

  #### Drip Allocation
  - Reserve space up front in multiples of the system allocation granularity (64 KB on Windows). Then gradually commit small chunks rather than one large contiguous block ‚Äî this reduces the likelihood of triggering EDR heuristics that flag suspicious large allocations, and helps blend in with normal application behavior.

  #### Module Stomping
  - Executing shellcode from .text of the current process leaves an IOC because the address is unbacked and doesn't point to a file on disk. You can map a sacrificial DLL into the process and stomp it so the address is backed. Using NtCreateSection with SEC_IMAGE triggers the PsSetLoadImageNotifyRoutine callback. A better OPSEC approach is to manually parse PE headers, allocate memory, copy sections, and apply relocations yourself.

  #### NtCreateThreadEx
  - Falcon is less sensitive to code injection into the same process and this function isn't currently hooked.

  #### Trampoline via breakpoint & direct instruction pointer setting (TBD)
  - Need to test if this is still viable option against Falcon.

  #### Indirect Syscalls (Will evolve with EDR modernization)
  - As mentioned previously, the main EDRs (Falcon, SentinelOne, and MDE) don't use ETWTI for call-stack tracing, meaning indirect syscalls currently work for execution. This could change in the future, and Elastic currently does perform call-stack tracing.  

  ### Call-Stack Spoofing
  - This blog provides an overview of call-stack spoofing to evade Elastic EDR <a href="https://dtsec.us/2023-09-15-StackSpoofin/" target="_blank">StackSpoofin blog</a>.  
  - The author created an implementation that uses indirect syscalls so it wouldn't hit EDR userland hooks.  
  - Neither Elastic nor MDE use hooking, but this would apply if Falcon starts checking call-stacks via the kernel.  
  - Current implementations online have the IOC that the JOP gadget for RBX isn't preceded by a call.  
  - In normal Windows execution, return addresses on the call stack are created when a call instruction pushes them onto the stack.  
  - However, inspection of call-stacks from LoadSunRun and SilentMoonwalk implementations will not show a call instruction before the return address, which is an IOC.  
  - That is why utilizing Rasta Mouse's <a href="https://github.com/rasta-mouse/GadgetHunter" target="_blank">GadgetHunter</a> implementation to use a JOP gadget with a call instruction before it would evade this.  
  - There is still a potential for an IOC because EDR could, after checking that the return address is preceded by a call instruction, verify that the call is targeting the function in the next frame. Though this isn't currently implemented in any EDR solutions.  

  #### Function Proxying
---

  ### ‚ö†Ô∏è Bad OPSEC Practices

  #### sRDI  
  - Donut's sRDI is signatured and will flag Falcon. Implementing a modified version is needed.  

  #### PPID Spoofing  
  - PPID spoofing works on MDE because it trusts ETW metadata, but Falcon catches it via kernel callbacks. 

  #### BlockDll Policy  
  - Falcon‚Äôs DLLs are signed by Microsoft, so this has no effect.  

  #### Arbitrary Code Guard  
  - Falcon‚Äôs DLLs are still injected into the process, and you substantially raise the chance of being flagged by creating a new process and injecting code into it.  

  #### SysWhispers2/3 
  - The assembly stubs are hardcoded and signatured so they are not good opsec vs dynamically resolving syscalls via Halos/Tartarus Gate.

  #### RemoteProcessInjection
  - Many new techniques try to evade EDR by creating a suspended process. This technique doesn't work against Falcon and they have specific detections for this. You also can't beat their DLL into the process, the second you resume a suspended process their dll is injected. Even if you try EarlyCascade technique. 
---


## üíâ Code Injection Techniques

<a href="https://github.com/itaymigdal/awesome-injection" target="_blank">awesome-injection</a>  
Centralized resource for listing and organizing known injection techniques and POCs


---


## Shellcode Execution Functions  

<a href="http://ropgadget.com/posts/abusing_win_functions.html" target="_blank">Abusing native Windows functions for shellcode execution</a>

---
