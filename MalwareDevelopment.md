# üõ°Ô∏è Windows EDR Evasion & Malware Development

Notes on malware development and EDR. Most notes will be based on CrowdStrike but I will highlight other EDRs as well.
Hot takes ahead. This document is based on personal experience and experimentation ‚Äî take it with a grain of salt.
---

## üìå Table of Contents

1. [EDR Components](#edr-hooks)  
2. [Kernel Callbacks & ETW](#kernel-callbacks--etw)  
3. [Malware OPSEC](#malware-opsec)  
4. [Loader Techniques](#loader-techniques)  
5. [Memory Allocation & Execution](#memory-allocation--execution)  
6. [Shellcode Injection Methods](#shellcode-injection-methods)  
---


## üß© EDR Components

- **User-mode API hooking**: After Microsoft introduced PatchGuard in 2005, security vendors moved their hooks from the kernel to user-mode APIs like those in `ntdll.dll`.  
  - [HookFinder](https://github.com/fin3ss3g0d/HookFinder) ‚Äì tool to detect hooked functions in `ntdll.dll`  
  - [CrowdStrike Hook Map](https://github.com/kyxiaxiang/AV_EDR_EPP_Notes) ‚Äì shows the functions CrowdStrike hooks in ntdll.  
  - This blog gives a good overview on the cat/mouse game for utilizing syscalls against EDR, https://d01a.github.io/syscalls/. 
  - Direct Syscalls IOC - Return address will point to .text and not ntdll. 
  - Indirect Syscall IOC - Using ETWTI stack tracing, EDRs can check where the system call orginated before jumping to ntdll. Which will show it came from .text. 

  <p>
Most popular EDRs are still not using ETW-TI (Event Tracing for Windows ‚Äì Threat Intelligence) for stack tracing. As the author of Brute Ratel pointed out in <a href="https://x.com/NinjaParanoid/status/1735682419569930362" target="_blank">this post</a>, CrowdStrike currently relies on Vectored Exception Handlers (VEH) for stack inspection rather than ETWTI. This remains true today, although it could change in the future. I‚Äôve seen direct syscall loaders bypass Falcon, which suggests they may not be leveraging <code>KPROCESS!InstrumentationCallback</code> to validate return addresses.
</p>
 

- **Kernel callbacks**:  
  - PsSetCreateThreadNotifyRoutine ‚Äì monitors thread creation and termination events  
  - PsSetCreateProcessNotifyRoutine ‚Äì monitors process creation and termination  
  - PsSetLoadImageNotifyRoutine ‚Äì tracks DLL and EXE image loads into process memory  
  - CmRegisterCallbackEx ‚Äì monitors registry operations like key creation, deletion, and value modification  
  - ObRegisterCallbacks ‚Äì monitors access to kernel objects like processes and threads, allowing filtering or blocking of handle operations

- **ETW-TI telementry**:
  - to track specific actions like allocations on executable pages and changing executable pages to writable
  - Can be used to trace call stacks but not widely used. 

- **Sandbox and Behavioral Analysis**:  
  - Runs suspicious files in a cloud sandbox to observe runtime behavior
  - Monitors process, registry, file, network, and memory activity
  - Scores behavior using heuristics, YARA rules, string, and entropy analysis to detect shellcode, suspicious API calls, and known malware traits.
  - Captures stack traces, API usage, and execution flow for forensic review

- **Cloud Telemetry and Cross-Endpoint Correlation**:  
  - Enables host-based behavioral correlation by linking related events (e.g., Outlook ‚Üí Edge ‚Üí Explorer ‚Üí cmd.exe ‚Üí conhost.exe ‚Üí binary.exe ‚Üí network comms)  
  - Uses IOCs, event sequences, and machine learning to flag anomalies across multiple systems  
  - Performs shadow upload of binary data from endpoints to support sandbox detonation and scoring, even when file submission is disabled

---

## üïµÔ∏è Malware OPSEC

- Utilizing powershell is risky due to script-block logging, especially with integration to Splunk which I see a lot. Script-Block logging is a feature of managed PowerShell host, so Cobalt Strike/Havoc's PowerPick can side-step this due to it being unmanaged. But it still requires loading System.Management.Automation.dll which blue teams can hook/monitor. 

- Memory IOC Scanning - PE-sieve, Moneta. Personally I haven't seen these tools live during red team engagements. In my experience if you bypass Falcon in memory your usually safe. Havoc beacon with return address spoofing and Foliage or Zilean sleep obfusication has done well. 

- Languages - CIA recommended malware should be under 150KB
  - Golang - Well above the limit; statically compiled with a large IAT. Uses its own runtime and stack layout, which differs from standard C/C++ calling conventions, making tracing harder.  
  - Rust - Also above the limit; its stack layout and compilation model differ from standard C/C++ conventions, which can complicate tracing. Unlike Go, Rust supports dynamic linking, allowing smaller binaries and more flexible deployment. 
  - C - Optimal for size, but easiest to trace since conventions and patterns are well understood by security tools.  
  - C++ - Also compact; classes add complexity. Vtable tracing is less automated in many analysis tools. 
  - C# - Can be under the size limit; every Windows client includes .NET (e.g., .NET Framework 4.7), and assemblies can run in memory by default with the CLR loaded. I have seen great success against Falcon with .Net assemblies, especially when AMSI and ETW are mitigated. You can also make a .Net assembly that runs unmanaged code such as indirect syscalls. 

  - If possible used aged domains, raw ips stick out. Use a seperate domain for exfilitration. 
  - Avoid shell commands, use bof files for modules that perform basic C2 functions. 
  - DCSync with SharpKatz via inline‚Äëexecute‚Äëassembly in Havoc C2 has proven effective. Performing DCSync remotely raises network red flags, but it‚Äôs a trade‚Äëoff. Falcon does not monitor DCSync by default, meaning detection relies on Sysmon rules and Splunk queries by security personnel. I would rather leave the success of the op contingent on the blue team‚Äôs competency rather than fighting the EDR directly.  

---

## üß™ Loader Techniques

- Call stack spoofing  
- Return address manipulation  
- Thread context hijacking  
- Manual mapping and reflective DLL loading


- [Birdnet PoC](https://github.com/inb1ts/birdnet-poc)  


---

## üß† Memory Allocation & Execution

- `VirtualAlloc`, `NtAllocateVirtualMemory`, and stealth tradeoffs  
- RWX memory detection and mitigation  
- Executing from non-standard memory regions  
- Avoiding common API footprints

---

## üíâ Shellcode Injection Methods

- Remote thread creation  
- APC and callback injection  
- Process hollowing and Doppelg√§nging  
- Shared memory and section mapping

---
