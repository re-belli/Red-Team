# üõ°Ô∏è Windows EDR Evasion & Malware Development

Notes on malware development and EDR. Most notes will be based on CrowdStrike but I will highlight other EDRs as well.  
Hot takes ahead. This document is based on personal experience and experimentation ‚Äî take it with a grain of salt.

---

## üìå Table of Contents

1. [EDR Components](#-edr-components)  
2. [Malware OPSEC](#-malware-opsec)  
3. [Loader Techniques](#-loader-techniques)  
4. [Memory Allocation Techniques](#-memory-allocation-techniques)  
5. [Copy Code](#-copy-code)  
6. [Code Injection Techniques](#-code-injection-techniques)  

---

## üß© EDR Components

- **User-mode API hooking**: After Microsoft introduced PatchGuard in 2005, security vendors moved their hooks from the kernel to user-mode APIs like those in `ntdll.dll`.  
  - [HookFinder](https://github.com/fin3ss3g0d/HookFinder) ‚Äì tool to detect hooked functions in `ntdll.dll`  
  - [Falcon Hooks in ntdll](https://github.com/kyxiaxiang/AV_EDR_EPP_Notes) ‚Äì shows the functions Falcon hooks in ntdll.  
  - This blog gives a good overview on the cat/mouse game for utilizing syscalls against EDR, https://d01a.github.io/syscalls/. 
  - Direct Syscalls IOC - Return address will point to .text and not ntdll. 
  - Indirect Syscall IOC - Using ETWTI stack tracing, EDRs can check where the system call orginated before jumping to ntdll. Which will show it came from .text. 

  <p>
Most popular EDRs are still not using ETW-TI (Event Tracing for Windows ‚Äì Threat Intelligence) for stack tracing. As the author of Brute Ratel pointed out in <a href="https://x.com/NinjaParanoid/status/1735682419569930362" target="_blank">this post</a>, Falcon currently relies on Vectored Exception Handlers (VEH) for stack inspection rather than ETWTI. This remains true today, although it could change in the future. I‚Äôve seen direct syscall loaders bypass Falcon, which suggests they may not be leveraging <code>KPROCESS!InstrumentationCallback</code> to validate return addresses.
</p>
 

- **Kernel callbacks**:  
  - PsSetCreateThreadNotifyRoutine ‚Äì monitors thread creation and termination events  
  - PsSetCreateProcessNotifyRoutine ‚Äì monitors process creation and termination  
  - PsSetLoadImageNotifyRoutine ‚Äì tracks DLL and EXE image loads into process memory  
  - CmRegisterCallbackEx ‚Äì monitors registry operations like key creation, deletion, and value modification  
  - ObRegisterCallbacks ‚Äì monitors access to kernel objects like processes and threads, allowing filtering or blocking of handle operations

- **ETW-TI telementry**:
  - to track specific actions like allocations on executable pages and changing executable pages to writable
  - Can be used to trace call stacks but not widely used. 

- **Sandbox and Behavioral Analysis**:  
  - Runs suspicious files in a cloud sandbox to observe runtime behavior
  - Monitors process, registry, file, network, and memory activity
  - Scores behavior using heuristics, YARA rules, string, and entropy analysis to detect shellcode, suspicious API calls, and known malware traits.
  - Captures stack traces, API usage, and execution flow for forensic review

- **Cloud Telemetry and Cross-Endpoint Correlation**:  
  - Enables host-based behavioral correlation by linking related events (e.g., Outlook ‚Üí Edge ‚Üí Explorer ‚Üí cmd.exe ‚Üí conhost.exe ‚Üí binary.exe ‚Üí network comms)  
  - Uses IOCs, event sequences, and machine learning to flag anomalies across multiple systems  
  - Performs shadow upload of binary data from endpoints to support sandbox detonation and scoring, even when file submission is disabled

---

## üïµÔ∏è Malware OPSEC

- Utilizing powershell is risky due to script-block logging, especially with integration to Splunk which I see a lot. Script-Block logging is a feature of managed PowerShell host, so Cobalt Strike/Havoc's PowerPick can side-step this due to it being unmanaged. But it still requires loading System.Management.Automation.dll which blue teams can hook/monitor. 

- Memory IOC Scanning - PE-sieve, Moneta. Personally I haven't seen these tools live during red team engagements. In my experience if you bypass Falcon in memory your usually safe. Havoc beacon with return address spoofing and Foliage or Zilean sleep obfusication has done well. 

- Languages - CIA recommended malware should be under 150KB
  - Golang - Well above the limit; statically compiled with a large IAT. Uses its own runtime and stack layout, which differs from standard C/C++ calling conventions, making tracing harder.  
  - Rust - Also above the limit; its stack layout and compilation model differ from standard C/C++ conventions, which can complicate tracing. Unlike Go, Rust supports dynamic linking, allowing smaller binaries and more flexible deployment. 
  - C - Optimal for size, but easiest to trace since conventions and patterns are well understood by security tools.  
  - C++ - Also compact; classes add complexity. Vtable tracing is less automated in many analysis tools. 
  - C# - Can be under the size limit; every Windows client includes .NET (e.g., .NET Framework 4.7), and assemblies can run in memory by default with the CLR loaded. I have seen great success against Falcon with .Net assemblies, especially when AMSI and ETW are mitigated. You can also make a .Net assembly that runs unmanaged code such as indirect syscalls. 

  - If possible used aged domains, raw ips stick out. Use a seperate domain for exfilitration. 
  - Avoid shell commands, use bof files for modules that perform basic C2 functions. 
  - DCSync with SharpKatz via inline‚Äëexecute‚Äëassembly in Havoc C2 has proven effective. Performing DCSync remotely raises network red flags, but it‚Äôs a trade‚Äëoff. Falcon does not monitor DCSync by default, meaning detection relies on Sysmon rules and Splunk queries by security personnel. I would rather leave the success of the op contingent on the blue team‚Äôs competency rather than fighting the EDR directly.

## üß™ Loader Techniques

  ### üîí Good OPSEC Practices

  #### Obfuscate Strings  
  Malicious strings that show DLL loading, API resolving, and network comms are bad OPSEC.  

  #### Stage Encrypted Shellcode  
  Falcon is highly sensitive to entropy and leverages Shannon entropy to measure the randomness of data. By staging encrypted shellcode and downloading it during execution, you can significantly reduce the entropy of the binary itself. In addition, using string lookup tables for encrypted strings ‚Äî with generic words as keys ‚Äî further lowers entropy. This approach also allows you to blend in strings taken from other signed or approved binaries.

  #### Remove IAT Imports  
  From an OPSEC perspective, it is often considered best practice to avoid having an Import Address Table (IAT). This also means removing the C Runtime (CRT), since it will automatically import many `Kernel32` libraries even if they are not explicitly used. In practice, this can be good OPSEC, but it is not strictly required ‚Äî as long as nothing directly related to malicious functionality appears in the IAT.

  #### Anti-Sandbox  
  Falcon has the best sandbox, and evading it is crucial to avoid flagging. Most public techniques are deprecated or ineffective, and Falcon detects long sleeps, even patching the sleep function in the IAT. Doing regular busy work and breaking up standard patterns of malicious actions works well, and implementing custom sorting algorithms can provide natural time gaps while making behavior harder to trace. Network communications are not executed inside the sandbox, which is why avoiding import libraries for comms in the IAT prevents patching. If you stick to regular computation and only act once a network callout succeeds, you have a better chance of avoiding detection.

  #### Unhooking  
  Falcon does a lot of its analysis via user‚Äëmode hooks. If you try to load C2s that aren‚Äôt implemented via direct/indirect syscalls, they will still flag even if the loader doesn‚Äôt. [Birdnet PoC](https://github.com/inb1ts/birdnet-poc)  

  #### Disable AMSI/ETW  
  Using hardware breakpoints is often considered good OPSEC online, but Falcon hooks `NtGetContextThread`, `NtSetContextThread`, `ZwGetContextThread`, and `ZwSetContextThread`. As a result, all the implementations I‚Äôve seen publicly available will be flagged.  
  A custom patch for `AmsiScan` in CLR works fine. For ETW, using an EAT hook or utilizing an egghunter to patch ETW also works.

  #### Custom Functions & Dynamic Linking  
  Falcon is extremely sensitive to having IAT entries that use default `GetProcAddress` and `GetModuleHandle` to resolve libraries, functions, and syscalls. Use custom implementations of these functions, and consider TartarusGate to resolve syscalls. On most Windows builds, the `SSN` can be found at the 4th byte of the function stub, while the actual `syscall` instruction is typically located at an offset of 0x12. By using an obfuscated or encrypted `GetProcAddress`, you can extract both the syscall ID and the syscall address to execute indirect syscall.

---

  ### ‚ö†Ô∏è Bad OPSEC Practices

  #### sRDI  
  Donut's sRDI is signatured and will flag Falcon. Implementing a modified version is needed.  

  #### PPID Spoofing  
  PPID spoofing works on MDE because it trusts ETW metadata, but Falcon catches it via kernel callbacks. 

  #### BlockDll Policy  
  Falcon‚Äôs DLLs are signed by Microsoft, so this has no effect.  

  #### Arbitrary Code Guard  
  Falcon‚Äôs DLLs are still injected into the process, and you substantially raise the chance of being flagged by creating a new process and injecting code into it.  

  #### SysWhispers2/3 
  The assembly stubs are hardcoded and signatured so they are not good opsec vs dynamically resolving syscalls via Halos/Tartarus Gate. 

---

## üß† Memory Allocation Techniques

  ### üîí Good OPSEC
  - Drip Allocation  
    Allocating memory in small, incremental chunks rather than large contiguous blocks. This reduces the likelihood of triggering EDR heuristics that flag suspicious large allocations, and helps blend in with normal application behavior.

---

  ### ‚ö†Ô∏è Bad OPSEC
  - Add RWX code segment or buffer ‚Äì Falcon flags RWX pages.  
      <pre><code>
      #pragma section(".code", execute, read, write)
      #pragma comment(linker,"/SECTION:.code,ERW")
      __declspec(allocate(".code")) unsigned char allocatedBuffer[1024];

      #pragma section(".text", read, write)
      __declspec(allocate(".text")) unsigned char allocatedBuffer[1024];
      </code></pre>

  - Allocate shellcode to text segment ‚Äì Having raw shellcode in the binary will be detected during initial behavioral analysis.  
      <pre><code>
      #pragma section(".text")
      __declspec(allocate(".text")) unsigned char shellcode[] = {
          0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90
      };
      </code></pre>

  - Using malloc for allocation and expanding the CRT heap to 1MB ‚Äì When the heap is initialized, `NtAllocateVirtualMemory` is called upfront. Subsequent calls to `malloc` will not trigger additional `NtAllocateVirtualMemory` calls unless the heap needs to grow. Heap memory is non‚Äëexecutable by default, and changing its page permissions to run shellcode is suspicious. Allocations are also non‚Äëcontiguous, making this method unsuitable for C2 payloads or non‚Äëposition‚Äëindependent shellcode.  
      <pre><code>
      code /HEAP:0x100000,0x100000
      </code></pre>

---

## ‚úçÔ∏è Copy Code

  ### üîí Good OPSEC
  - Custom memcpy implementation ‚Äì This avoids leaving obvious footprints in the Import Address Table and helps reduce detection risk.

---

  ### ‚ö†Ô∏è Bad OPSEC
  - Using CRT memcpy, NtWriteVirtualMemory, or RtlMoveMemory ‚Äì These functions create IAT references, which are easily flagged during analysis.

---

## üíâ Code Injection Techniques

<a href="https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/tree/main?tab=readme-ov-file#process-hollowing" target="_blank">Win32 and Kernel abusing techniques</a>  
This resource contains many common shellcode injection techniques.

### üîí Good OPSEC
- Module Stomping ‚Äì Using NtCreateSection with SEC_IMAGE triggers the PsSetLoadImageNotifyRoutine callback. A better OPSEC approach is to manually parse PE headers, allocate memory, copy sections, and apply relocations yourself.
- Trampoline via breakpoint & direct instruction pointer setting  
- NtCreateThreadEx - Falcon is less sensitive to code injection into the same process and this function isn't currently hooked.

---

### ‚ö†Ô∏è Bad OPSEC
- CreateRemoteThread injection  
- Process Hollowing  
- APC Queue Technique  
- Early Bird  
- Reflective DLL Injection  
- DLL Injection  
- Process Doppelganging  
- Fibers  
- MapView code injection  
- Function Pointer Execution  
- Thread Hijacking  


---
